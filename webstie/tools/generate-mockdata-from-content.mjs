#!/usr/bin/env node
/**
 * Content to MockData Generator
 * 
 * Reads markdown files from content/ folders and generates
 * project-hub-x/integrations/cms/mock-data.ts
 * 
 * This allows CMS edits to automatically update the frontend data
 * without modifying any frontend source code.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.join(__dirname, '..');

// Parse frontmatter from markdown files
function parseFrontmatter(content) {
  const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---/;
  const match = content.match(frontmatterRegex);
  
  if (!match) return null;
  
  const frontmatter = match[1];
  const data = {};
  
  // Simple YAML parser for our use case
  const lines = frontmatter.split('\n');
  let currentKey = null;
  let currentList = null;
  
  for (const line of lines) {
    if (line.trim() === '') continue;
    
    // List item
    if (line.trim().startsWith('- ')) {
      if (currentList) {
        currentList.push(line.trim().substring(2));
      }
      continue;
    }
    
    // Key-value pair
    const colonIndex = line.indexOf(':');
    if (colonIndex > 0) {
      const key = line.substring(0, colonIndex).trim();
      let value = line.substring(colonIndex + 1).trim();
      
      // Handle different value types
      if (value === 'true') value = true;
      else if (value === 'false') value = false;
      else if (!isNaN(value) && value !== '') value = Number(value);
      else if (value === '') {
        // This might be a list
        currentKey = key;
        currentList = [];
        data[key] = currentList;
        continue;
      }
      
      data[key] = value;
      currentKey = key;
      currentList = null;
    }
  }
  
  return data;
}

// Read all markdown files from a directory
function readContentFromDir(dirPath) {
  const items = [];
  
  if (!fs.existsSync(dirPath)) {
    console.log(`Directory ${dirPath} does not exist, skipping...`);
    return items;
  }
  
  const files = fs.readdirSync(dirPath);
  
  for (const file of files) {
    if (file === '.gitkeep' || !file.endsWith('.md')) continue;
    
    const filePath = path.join(dirPath, file);
    const content = fs.readFileSync(filePath, 'utf-8');
    const data = parseFrontmatter(content);
    
    if (data) {
      // Add ID and dates
      const filename = path.basename(file, '.md');
      data._id = `${path.basename(dirPath)}_${filename}`;
      data._createdDate = data.createdDate || new Date().toISOString();
      data._updatedDate = new Date().toISOString();
      
      // Handle multi-line text fields (features, deliverables)
      if (typeof data.features === 'string' && data.features.includes('\n')) {
        data.features = data.features.split('\n').filter(f => f.trim()).join('\n');
      }
      
      // Convert text features to array for compatibility
      if (typeof data.features === 'string') {
        data.featuresArray = data.features.split('\n').filter(f => f.trim());
      }
      
      // Only include published items
      if (data.published !== false) {
        items.push(data);
      }
    }
  }
  
  return items;
}

// Generate the mockData.ts file
function generateMockDataFile() {
  console.log('üöÄ Generating mockData from content...\n');
  
  const contentDir = path.join(rootDir, 'content');
  
  // Read all collections
  const collections = {
    readymadeprojects: readContentFromDir(path.join(contentDir, 'projects')),
    customprojectrequests: readContentFromDir(path.join(contentDir, 'requests')),
    faq: readContentFromDir(path.join(contentDir, 'faq')),
    howitworkssteps: readContentFromDir(path.join(contentDir, 'steps')),
    clienttestimonials: readContentFromDir(path.join(contentDir, 'testimonials')),
    developerprofiles: readContentFromDir(path.join(contentDir, 'developers'))
  };
  
  // Log what we found
  console.log('üìä Content Statistics:');
  console.log(`   - Projects: ${collections.readymadeprojects.length}`);
  console.log(`   - FAQ: ${collections.faq.length}`);
  console.log(`   - Testimonials: ${collections.clienttestimonials.length}`);
  console.log(`   - Steps: ${collections.howitworkssteps.length}`);
  console.log(`   - Developers: ${collections.developerprofiles.length}`);
  console.log(`   - Requests: ${collections.customprojectrequests.length}`);
  console.log('');
  
  // Generate TypeScript file content
  const tsContent = `// AUTO-GENERATED FILE
// This file is automatically generated from content/ folder
// DO NOT EDIT MANUALLY - Your changes will be overwritten
// Last generated: ${new Date().toISOString()}

interface MockCollection {
  [key: string]: any[];
}

// In-memory data store populated from CMS content
const mockDataStore: MockCollection = ${JSON.stringify(collections, null, 2)};

// Initialize with CMS-managed data
export const initializeMockData = () => {
  console.log('‚úÖ Mock data initialized from CMS content');
  console.log('   - Projects:', mockDataStore.readymadeprojects.length);
  console.log('   - FAQ:', mockDataStore.faq.length);
  console.log('   - Testimonials:', mockDataStore.clienttestimonials.length);
  console.log('   - Steps:', mockDataStore.howitworkssteps.length);
  console.log('   - Developers:', mockDataStore.developerprofiles.length);
};

export const getMockCollection = (collectionId: string) => {
  if (!mockDataStore[collectionId]) {
    mockDataStore[collectionId] = [];
  }
  return mockDataStore[collectionId];
};

export const setMockCollection = (collectionId: string, data: any[]) => {
  mockDataStore[collectionId] = data;
};

export { mockDataStore };
`;
  
  // Write the file
  const outputPath = path.join(rootDir, 'project-hub-x', 'integrations', 'cms', 'mock-data.ts');
  fs.writeFileSync(outputPath, tsContent, 'utf-8');
  
  console.log('‚úÖ Generated: project-hub-x/integrations/cms/mock-data.ts');
  console.log('');
  console.log('üéâ Content sync complete!');
}

// Run the generator
try {
  generateMockDataFile();
} catch (error) {
  console.error('‚ùå Error generating mockData:', error);
  process.exit(1);
}
